# 事务、数据库事务、分布式事务

## 什么是事务

事务是一个非常广义的词汇，各行各业解读都不一样。

对于程序员，事务等价于Transaction，是指一组连续的操作，这些操作组合成一个逻辑的、完整的操作。即这组操作执行前后，系统需要处于一个可预知的、一致的状态。因此，这一组操作要么都成功执行，要么都不能执行；如果部分成功，部分失败，成功的部分需要回滚（rollback）。

数据库事务（简称：事务，Transaction）是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。

事务拥有以下四个特性，习惯上被称为 ACID 特性：

- 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。

- 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态是指数据库中的数据应满足完整性约束。除此之外，一致性还有另外一层语义，就是事务的中间状态不能被观察到（这层语义也有说应该属于原子性）。

- 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行，如同只有这一个操作在被数据库所执行一样。

- 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。在事务结束时，此操作将不可逆转。

### 两阶段提交（2pc, two-phase commit protocol），又叫做 XA Transactions

XA 是一个两阶段提交协议，该协议分为以下两个阶段：

- 第一阶段：

	事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.

- 第二阶段：

	事务协调器要求每个数据库提交数据。

2pc是非常经典的强一致性、中心化的原子提交协议。

- 强一致性

	todo

- 中心化

	指协议中有两类节点：一个中心化协调者节点（coordinator）和N个参与者节点（participant、cohort）。
	
讨论2PC的优缺点：

- 优点：

	强一致性，只要节点或者网络最终恢复正常，协议就能保证顺利结束；部分关系型数据库（Oracle）、框架直接支持

- 缺点：

	两阶段提交协议的容错能力较差，比如在节点宕机或者超时的情况下，无法确定流程的状态，只能不断重试；两阶段提交协议的性能较差， 消息交互多，且受最慢节点影响

## 分布式理论

### CAP定理

当我们的单个数据库的性能产生瓶颈的时候，我们可能会对数据库进行分区，这里所说的分区指的是物理分区，分区之后可能不同的库就处于不同的服务器上了，这个时候单个数据库的ACID已经不能适应这种情况了，而在这种ACID的集群环境下，再想保证集群的ACID几乎是很难达到，或者即使能达到那么效率和性能会大幅下降，最为关键的是再很难扩展新的分区了，这个时候如果再追求集群的ACID会导致我们的系统变得很差，这时我们就需要引入一个新的理论原则来适应这种集群的情况，就是 CAP 原则或者叫CAP定理。

CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足一下3个属性：

- 一致性(Consistency) ： 

	客户端知道一系列的操作都会同时发生(生效)
	
- 可用性(Availability) ： 

	每个操作都必须以可预期的响应结束

- 分区容错性(Partition tolerance) ： 

	即使出现单个组件无法可用,操作依然可以完成

具体地讲在分布式系统中，在任何数据库设计中，一个Web应用至多只能同时支持上面的两个属性。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在一致性与可用性之间做出选择。

### BASE理论

在分布式系统中，我们往往追求的是可用性，它的重要程序比一致性要高，那么如何实现高可用性呢？ 前人已经给我们提出来了另外一个理论，就是BASE理论，它是用来对CAP定理进行进一步扩充的。

BASE理论指的是：

- Basically Available（基本可用）

- Soft state（软状态）

- Eventually consistent（最终一致性）

BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。

## 分布式事务模型

### 基于XA的分布式事务模型

两阶段提交（2PC, two-phase commit）

todo

三阶段提交（3PC, three-phase commit）

todo

### 基于TCC的分布式事务模型

TCC事务机制相对于传统事务机制（X/Open XA），其特征在于它不依赖资源管理器(RM)对XA的支持，而是通过对（由业务系统提供的）业务逻辑的调度来实现分布式事务。

1. 初步操作（Try）
TCC事务机制中的业务逻辑（Try），从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，是不一样的。TCC机制中的Try仅是一个初步操作，它和后续的次确认一起才能真正构成一个完整的业务逻辑。因此，可以认为[传统事务机制]的业务逻辑 = [TCC事务机制]的初步操作（Try） + [TCC事务机制]的确认逻辑（Confirm）。TCC机制将传统事务机制中的业务逻辑一分为二，拆分后保留的部分即为初步操作（Try）；而分离出的部分即为确认操作（Confirm），被延迟到事务提交阶段执行。

TCC事务机制以初步操作（Try）为中心，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其不良影响进行回撤。

2. 确认操作（Confirm）
确认操作（Confirm）是对初步操作（Try）的一个补充。当TCC事务管理器认为全局事务可以正确提交时，就会逐个执行初步操作（Try）指定的确认操作（Confirm），将初步操作（Try）未完成的事项最终完成。

3. 取消操作（Cancel）
取消操作（Cancel）是对初步操作（Try）的一个回撤。当TCC事务管理器认为全局事务不能正确提交时，就会逐个执行初步操作（Try）指定的取消操作（Cancel），将初步操作（Try）已完成的事项全部撤回。

补偿事务（TCC，Try、Commit、Cancel）

TCC和两阶段分布式事务处理的区别

#### 通用型TCC解决方案

所有从业务服务都需要参与到主业务服务的决策当中。

![Alt text](https://github.com/LuckyTerry/ReadingNotes/raw/master/Screenshots/general-tcc.jpg)

#### 异步确保型TCC解决方案

#### 补偿型TCC解决方案

### 基于消息的分布式事务

本地消息表（异步确保）

MQ 非事务消息

MQ 事务消息

### Sagas 事务模型

1PC（ One-phase commit，一阶段提交）

todo

### 其他





## 参考资料

[聊聊分布式事务，再说说解决方案](https://www.jianshu.com/p/e70e84dbab72) 